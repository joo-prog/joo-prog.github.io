---
title: BOJ 1932번 정수 삼각형 (Python)
categories: BOJ
tags: [BOJ, python]
toc: True
toc_label: "BOJ #1932"
toc_sticky: True
---

## 문제
<span style="font-size:0.9em">:computer_mouse:
<a href='https://www.acmicpc.net/problem/1932' target='_blank' style="color: #2F4F4F; font-size:0.9em">
  문제 링크(클릭)
</a>
</span><br><br>
```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

### 입력
> 첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

### 출력
> 첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

* 예시1
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

* 예시1 출력
```
30
```

## My Solution
문제 보는 순간 이건 DP문제라는 것을 맞췄다는게 뿌듯한 문제였다. 지금까지 풀어본 문제 유형 중에 내가 제일 약한 부분이 DP라고 생각이 들었는데 쉬운문제지만 그걸 알아챘다는게 기분 좋았다.😆<br><br>
문제 푼 방식을 살펴보면 우선 `tri`라는 리스트에 입력을 받았다. 그리고 난 후에 이걸 한줄 씩 입력받으면서 바로바로 처리할 수는 없을까하고 생각을 해봤고 가능한 방법이었다. 두번째줄부터 입력받은 후에 처리를 하면 되는데 이 때 입력받은 리스트의 길이만큼 for문을 돌도록 했다. 그 다음 두가지 경우가 존재한다. 예를 들어 살펴보자.<br>
```
  3   7
8   1   0
```
두번째 줄을 기준으로 보게 되면 첫번째 경우는 8과 0과 같은 양 끝의 숫자이고 두번째는 1과 같은 양 끝 숫자를 제외한 나머지 숫자이다. 첫번째의 경우에는 해당 숫자에 더해질 수 있는 윗줄의 숫자는 딱 한가지 경우밖에 없다. 8의 경우에는 3, 0의 경우에는 7을 더할 수 밖에 없는 구조이기 때문에 index를 활용하여 더해주었다. <br>
그 다음 1과 같은 두번째 경우이다. 이 경우에는 더할 수 있는 숫자가 3, 7 이렇게 두가지가 있다. 하지만 문제가 최대합을 만드는 것이므로 두 개의 숫자 중에서 큰 수를 더하는 것이 정답과 가까워질 수 있는 길이다. 그렇기 때문에 두 수 중에 max값을 찾아서 1에 더해서 업데이트해주는 형태로 코드를 짰다.<br><br>
이런식으로 한줄을 새로 업데이트 해준 다음에 다음줄 입력을 받고 또 이방식을 반복하게 된다면 `tri`의 마지막 줄에는 최종으로 업데이트된 값들이 저장되어있을 것이다. 따라서 `tri`의 마지막 줄에서의 max값을 찾으면 그것이 정수 삼각형에서 최대의 합이라고 할 수 있는 것이다.

### 코드
{% highlight python linenos %}
import sys
input=sys.stdin.readline

n=int(input())
tri=[]
for i in range(n):
    tri.append(list(map(int, input().split())))
    
    if i!=0:
        for j in range(len(tri[i])):
            if j==0:
                tri[i][j]+=tri[i-1][j]
            elif j==len(tri[i])-1:
                tri[i][j]+=tri[i-1][j-1]
            else:
                tri[i][j]+=max(tri[i-1][j], tri[i-1][j-1])

print(max(tri[n-1]))
{% endhighlight %}