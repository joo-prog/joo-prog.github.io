---
title: BOJ 2164번 카드2 (Python)
categories: BOJ
tags: [BOJ, python]
toc: True
toc_label: "BOJ #2164"
toc_sticky: True
---

## 문제
<span style="font-size:0.9em">:computer_mouse:
<a href='https://www.acmicpc.net/problem/2164' target='_blank' style="color: #2F4F4F; font-size:0.9em">
  문제 링크(클릭)
</a>
</span><br><br>
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.

N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

### 입력
>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.
```
6
```

### 출력
> 첫째 줄에 남게 되는 카드의 번호를 출력한다.
```
4
```

## My Solution
이 문제를 보고 '자료구조를 이럴 때 쓸 수 있구나'하면서 뿌듯했다. (물론 시간초과뜨기 전까지만)<br>
문제가 맨 위를 꺼내서 버리고 또 그 다음에는 맨 위에 원소들을 마지막에 삽입하고 이거 완전 '큐로 풀어주세요!:raised_hand:`라고 써있네라고 생각하면서 룰루랄라 코드를 짰다. 다 짜고 입력이 500,000까지 가능한걸 보고 약간 불안했지만 저렇게 대놓고 큐를 쓰라는 듯이 해놓고 안될까했지만 시간초과가 떴다:sob:

### 실패한 코드 - 시간초과
{% highlight python linenos %}
n=int(input())

queue=[num for num in range(1,n+1)]

flag=1
while len(queue)!=1:
    if flag%2==1:
        queue.pop(0)
        flag=2
    else:
        tmp=queue.pop(0)
        queue.append(tmp)
        flag=1

print(queue[0])
{% endhighlight %}
<br>
도저히 큐로는 시간초과를 해결할 자신이 없어서 다른 방법을 생각해보려했다. 그래서  손으로 문제를 풀어가며 1부터 하나씩 어떤 원리로 output이 나오나 써봤다. <br>
6이 예시로 나와있으니 그 주변 숫자 7, 5를 먼저 해봤더니 5일때는 2, 7일때는 6이 나왔다. 여기서 결과가 input 5, 6, 7 순서대로 output이 2, 4, 6이어서 '오잉?' 했다.
단순한 우연의 일치라고 생각해 한 번 더 4, 8을 해봤더니 '와 설마?'했다. 그러고 의심이 많은 나는 1부터 17까지 다 해봤다. 그 결과는 바로 다음과 같다.

|Input|output|
|---|---|
|1|1|
|2|2|
|**3**|**2**|
|4|4|
|**5**|**2**|
|6|4|
|7|6|
|8|8|
|**9**|**2**|
|10|4|

<br>
나는 17까지 해봤지만 여기까지만 해도 큰 규칙은 보이니까 10까지만 적겠다.<br>
다들 규칙이 보이나요? 1과 2를 제외하고 3부터 output만 끊어서 보게 되면 (2, 4), (2, 4, 6, 8), (2, 4, 6, 8, ...)...이 반복되는 것을 확인할 수 있다.<br>
규칙은 알아냈고 이제 수식화를 해야해서 input과 output의 관계를 살펴봤다.

|Input|output|
|---|---|
|3|2=2x1=2x(3-2)|
|4|4=2x2=2x(4-2)|
|5|2=2x1=2x(5-4)|
|6|4=2x2=2x(6-4)|
|7|6=2x3=2x(7-4)|
|8|8=2x4=2x(8-4)|
|9|2=2x1=2x(9-8)|
|10|4=2x2=2x(10-8)|

위와 같이 input과 output을 관계지을 수 있었다. <br>
정리하면,
> input = 2 x (input-input보다 작은 2의 거듭제곱)

의 관계식을 얻을 수 있었다.<br>
수식으로 코드짜니 input 최대치인 500,000의 결과도 바로 나왔고 제출했더니 시간초과도 안뜨고 순식간에 정답이 떴다!

### 성공한 코드
{% highlight python linenos %}
n=int(input())
tmp=2

if (n==1) | (n==2):
    print(n)
else:
    while(1):
        if tmp*2>=n:
            break
        tmp*=2
    
    print(2*(n-tmp))

{% endhighlight %}
<br>
처음에는 큐를 써야만 할 것 같아서 <strike>(거의 쓰라고 써놓은거 아니냐..)</strike> 써서 풀었다가 시간초과나서 결국은 수학적으로 해결한 문제다.
물론 큐를 써서 해결할 수 있는 방법도 찾아보면 있을 것이다.(아마도?)
아무튼 그래도 규칙을 발견해서 잘 풀어서 뿌듯하다:relaxed: